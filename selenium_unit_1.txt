Selenium — комплекс решений для автоматизации работы браузеров и тестирования веб-приложений.
Инструменты имеют открытый исходный код, что дает возможность тестировщикам менять продукты
Selenium под свои запросы.

Selenium: преимущества и недостатки
Основные продукты Selenium
Selenium WebDriver
Selenium RC (Remote Control)
Selenium Server
Selenium Grid
Selenium IDE


Selenium WebDriver — универсальный интерфейс, который позволяет манипулировать
разными браузерами напрямую из кода на языке программирования

-----способы поиска элементов внутри страницы-----:

1.Поиск с помощью CSS-селекторов, когда путь к элементу описывается через синтаксис CSS.
Селектор — это описание пути к элементу на странице.
2.Поиск с помощью указания значений тегов или атрибутов элементов: ID, class, и т.д.
3.Поиск с помощью языка запросов XPath.


Три особенности языка HTML:

1.Страница на языке HTML состоит из элементов, начало и конец элемента задаются с помощью специальных
пометок – тегов (tag);
2.У тегов есть атрибуты, которые определяют свойства элементов;
3.Страница на языке HTML имеет иерархическую структуру.

1.Tag – элемент или тег
Начало и конец элементов обрамляются специальными словами – тегами (tag)
<p>Здесь написан текст.</p>

2.Attribute – атрибуты или свойства элемента
Элементам можно задавать различные стандартные свойства, а также создавать собственные свойства
или атрибуты:

имя="значение"

Атрибут class---
Элементу задано два класса: simple-text и main:

<div class="simple-text main">Здесь написан текст.</div>

Атрибут name---
Свойство name, например, используется для задания якоря (закладки) в html-странице:

<a name="top"></a>

Атрибут id---
В этом примере появился еще атрибут id – уникальный указатель на элемент. Значение id в общем случае
не должно повторяться в пределах страницы:

<button id="save_button">Сохранить</button>

Давайте разберёмся с терминологией данного древа:

потомок элемента X – элемент любой степени вложенности внутри элемента X;
ребёнок или дочерний элемент — прямой потомок (т.е. элемент на первом уровне вложенности);
предок элемента Y – любой элемент X, который включает в себя элемент Y;
родитель — это прямой предок (т.е. элемент, который расположен выше строго на 1 уровень);
братский или соседний элемент – элемент X, который расположен на одном уровне иерархии с элементом Y.
Элементы X и Y имеют одного родителя.

Селектор - путь к элементу в древовидной структуре html

Ниже приведены части элементов HTML-страницы, по которым можно найти элемент:

id
tag
значение атрибута
name
class

--Поиск по id--
Какое везение! У элемента с нашей картинкой есть атрибут id="bullet", а значит, мы однозначно можем
найти её с помощью селектора #bullet (знак # означает, что мы ищем по id со значением bullet).

--Поиск по tag--
Чтобы найти элемент по тегу, просто напишите название тега в поисковой строке, как мы делали это при
поиске по id (только без знака #), например, h1

--Поиск по значению атрибута--
Можно найти элемент, указав название атрибута и его значение. Например, можно переписать поиск по id в
следующем виде [id="bullet"] вместо #bullet.

--Поиск по name--
Этот вариант поиска является разновидностью поиска по значению атрибута и
записывается так же: [name="bullet-cat"]

--Поиск по class--
Поиск по классу можно записать в виде [class="jumbotron-heading"], так как class тоже является атрибутом
элемента. Но раз уж классы используются практически в каждой странице при задании стилей страниц,
то для них также имеется свой короткий вариант поиска: .jumbotron-heading.Для уточнения селектора можно
задать также оба класса, для этого нужно добавить второй класс к строке поиска без пробела и
предварить его точкой: .lead.text-muted

Поиск элементов с помощью составных CSS-селекторов

Использование потомков:
#post2 .title
Использование дочерних элементов:
#post2 > div.title

Здесь мы указали еще тег элемента div и уточнили, что нужно взять элемент с тегом и
классом: div.title, который находится строго на один уровень иерархии ниже чем элемент #post2.
Для этого используется символ >.Элемент #post2 в этом случае называется родителем (англ. parent)
для элемента div.title, а элемент div.title называется дочерним элементом (англ. child) для элемента
#post2. Если символа > нет, то будет выполнен поиск всех элементов div.title на любом уровне ниже
первого элемента.
!Внимание. В данном случае символы пробела вокруг символа ">" не несут важного значения в отличие от
предыдущего примера, и могут быть опущены. Запись #post2>div.title аналогична записи #post2 > div.title.

Использование порядкового номера дочернего элемента

еще один способ найти этот элемент:

#posts > .item:nth-child(2) > .title

Псевдо-класс :nth-child(2) — позволяет найти второй по порядку элемент среди дочерних элементов для
#posts. Затем с помощью конструкции > .title мы указываем, что нам нужен элемент .title, родителем
которого является найденный ранее элемент .item.

 Использование нескольких классов
Также мы можем использовать сразу несколько классов элемента, чтобы его найти. Для этого классы
записываются подряд через точку: .title.second


--Поиск элементов с помощью XPath--

На тему XPath мнения расходятся, но, как бы то ни было, это мощный и гибкий инструмент, который
позволяет писать сложные запросы для поиска элементов.

Прежде всего, XPath (XML Path Language) это язык запросов, который использует древовидную структуру
документа. Проверять XPath-запросы можно точно так же как и CSS-селекторы — в консоли разработчика.

1.XPath запрос всегда начинается с символа / или //
Символ / аналогичен символу > в CSS-селекторе, а символ // — пробелу. Их смысл:

el1/el2 — выбирает элементы el2, являющиеся прямыми потомками el1;
el1//el2 — выбирает элементы el2, являющиеся потомками el1 любой степени вложенности.
Разница состоит в том, что в XPath, когда мы начинаем запрос с символа /,  мы должны указать элемент,
являющийся корнем нашего документа. Корнем всегда будет элемент с тегом <html>.
Пример: /html/body/header

Мы можем начинать запрос и с символа //. Это будет означать, что мы хотим найти всех потомков корневого
элемента без указания корневого элемента. В этом случае, для поиска того же хедера, мы можем выполнить
запрос //header, так как других заголовков у нас нет.

2. Символ [ ] — это команда фильтрации


Правил фильтрации очень много:

по любому атрибуту, будь то id, class, title (или любой другой). Например, мы хотим найти картинку с
летящим котом, для этого можно выполнить запрос //img[@id='bullet']
по порядковому номеру. Допустим, мы хотим выбрать вторую по порядку карточку с котом. Для этого найдем
элемент с классом "row" и возьмем его второго потомка: //div[@class="row"]/div[2]
по полному совпадению текста. Да, XPath — это единственный способ найти элемент по внутреннему тексту.
Если мы хотим найти блок текста с котом-Лениным, можно воспользоваться XPath
селектором //p[text()="Lenin cat"]. Такой селектор вернет элемент, только если текст полностью
совпадет. Здесь важно сказать, что не всегда поиск по тексту — это хорошая практика, особенно в случае
 мультиязычных сайтов.
по частичному совпадению текста или атрибута. Для этого нужна функция contains.
Запрос //p[contains(text(), "cat")] вернет нам все абзацы текста, которые содержат слово cat.
Точно так же можно искать по частичному совпадению других атрибутов, это удобно, если у элемента
несколько классов. Посмотрите на код навбара сайта с котами. Его можно найти
селектором //div[contains(@class, "navbar")]
в фильтрации еще можно использовать булевы операции (and, or, not) и некоторые простые арифметические
 выражения (но вообще не стоит, наверное). Допустим, мы хотим найти картинку обязательно с
 data-type "animal" и именем "bullet-cat", для этого подойдет
  запрос: //img[@name='bullet-cat' and @data-type='animal']

3.Символ * — команда выбора всех элементов
Например можем найти текст в заголовке запросом //div/*[@class="jumbotron-heading"]. Это может быть
удобно, когда мы не знаем точно тег элемента, который ищем.

4. Поиск по классу в XPath регистрозависим
Также как и в случае поиска по CSS-селектором будьте внимательными к регистру при поиске по классам:

//div/*[@class="Jumbotron-heading"] не найдет элемент на нашей странице.

Что важно знать про XPath, чтобы пользоваться им безболезненно:

Не используйте селекторы вида //div[1]/div[2]/div[3] без крайней нужды: по такому селектору невозможно
с первого раза понять, что за элемент вы ищете. А когда структура страницы хоть немного изменится, то
ваш селектор с большой вероятностью перестанет работать;
Если есть возможность использовать CSS-селекторы: сlass, id или name — лучше использовать их вместо
поиска по XPath;
Можно искать по полному или частичному совпадению текста или любого атрибута;
Можно использовать булевы операции и простую арифметику;
Можно удобно перемещаться по структуре документа (переходить к потомкам и к родителям);
Подойдет, когда у сайта всё плохо с атрибутами и нет возможности достучаться до разработчиков;
Есть мнение, что поиск по XPath в среднем медленнее, чем по css. Но достоверно это неизвестно;
Не стоит использовать разные расширения для браузеров по поиску XPath: они подбирают нечитабельные и
переусложненные селекторы. Лучше потратить немного времени и разобраться в синтаксисе самостоятельно,
тем более, что он не очень сложный.


---Поиск элементов с помощью Selenium----
Для поиска элементов на странице в Selenium WebDriver используются несколько стратегий, позволяющих
искать по атрибутам элементов, текстам в ссылках, CSS-селекторам и XPath-селекторам. Для поиска Selenium
предоставляет метод find_element, который принимает два аргумента - тип локатора и значение локатора.
Существуют следующие методы поиска элементов:

find_element(By.ID, value) — поиск по уникальному атрибуту id элемента. Если ваши разработчики
проставляют всем элементам в приложении уникальный id, то вам повезло, и вы чаще всего будет использовать
этот метод, так как он наиболее стабильный;

find_element(By.CSS_SELECTOR, value) — поиск элемента с помощью правил на основе CSS. Это универсальный
метод поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам.
Если find_element_by_id вам не подходит из-за отсутствия id у элементов, то скорее всего вы будете
использовать именно этот метод в ваших тестах;

find_element(By.XPATH, value) — поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий
поиск элементов;

find_element(By.NAME, value) — поиск по атрибуту name элемента;

find_element(By.TAG_NAME, value) — поиск элемента по названию тега элемента;

find_element(By.CLASS_NAME, value) — поиск по значению атрибута class;

find_element(By.LINK_TEXT, value) — поиск ссылки на странице по полному совпадению;

find_element(By.PARTIAL_LINK_TEXT, value) — поиск ссылки на странице, если текст селектора совпадает с
любой частью текста ссылки.



---Работа с браузером---
Если вы уже пробовали запускать примеры скриптов, то могли заметить, что браузер не всегда закрывается
после выполнения кода. Поэтому обратите внимание на то, что необходимо явно закрывать окно браузера в
нашем коде при помощи команды browser.quit(). Каждый раз при открытии браузера browser = webdriver.Chrome()
в системе создается процесс, который останется висеть, если вы вручную закроете окно браузера. Чтобы не
остаться без оперативной памяти после запуска нескольких скриптов, всегда добавляйте к своим скриптам
команду закрытия:

from selenium import webdriver
from selenium.webdriver.common.by import By


link = "http://suninjuly.github.io/simple_form_find_task.html"
browser = webdriver.Chrome()
browser.get(link)
button = browser.find_element(By.ID, "submit_button")
button.click()

# закрываем браузер после всех манипуляций
browser.quit()



Важно еще пояснить разницу между двумя командами: browser.close() и browser.quit(). Какая между ними
разница, ведь на первый взгляд обе они осуществляют одно и то же?

На самом деле, browser.close() закрывает текущее окно браузера. Это значит, что если ваш скрипт вызвал
всплывающее окно, или открыл что-то в новом окне или вкладке браузера, то закроется только текущее окно,
а все остальные останутся висеть. В свою очередь browser.quit() закрывает все окна, вкладки, и процессы вебдрайвера, запущенные во время тестовой сессии. Подробнее можно посмотреть здесь: Difference between webdriver.Dispose(), .Close() and .Quit(). Будьте внимательны с этими методами и, в общем случае, всегда используйте browser.quit().

Но что будет, если скрипт не дойдет до выполнения этого финального шага, а упадет с ошибкой где-то раньше?

Для того чтобы гарантировать закрытие, даже если произошла ошибка в предыдущих строках, проще всего
использовать конструкцию try/finally:

from selenium import webdriver
from selenium.webdriver.common.by import By

link = "http://suninjuly.github.io/simple_form_find_task.html"

try:
    browser = webdriver.Chrome()
    browser.get(link)
    button = browser.find_element(By.ID, "submit_button")
    button.click()

finally:
    # закрываем браузер после всех манипуляций
    browser.quit()

Подробно говорить об обработке исключений мы сейчас не будем, здесь важно понимать только то, что даже
если в коде внутри блока try произойдет какая-то ошибка, то код внутри блока finally выполнится в любом
случае